---
layout:     post
title:      【课堂笔记】CSAPP L2 Bit,Bytes, and Intergers
subtitle:   SDN网络
date:       2020-10-24
author:     haoran
header-img: img/lake.png
catalog: true
tags: 
    - CSAPP
    - encoding

typora-root-url: ..
---



Lecture3
1. 位表示
2. 位级别的操作
3. 整数
    - 表示：无符号和有符号
    - 约定和转换
    - 扩展和截断
    - 加法，减法，乘法，移位
4. 内存，指针，字符串的表示
5. 总结

02:32 无符号数的加法
06:19 无符号运算加法的可视化
06:42 补码的加法
13:42 补码加法的可视化

15:02 无符号数的乘法
17:20 C中有符号数的乘法
24:33 2的指数幂乘法和左移等价
26:32 2的指数幂除法和右移等价
28:48 逻辑移位和算术移位应用
36:03 不要使用无符号数的原因
39:03 如果使用无符号数的规范
44:22 使用无符号数的原因

44:56 内存，指针，字符串的表示
48:00 内存的结构梳理
49:39 机器的字长
53:14 面向字节的内存结构
【这里关于内存，需要推荐一下另一门课《十分钟计算机科学-内存部分》，看完对这部分会有更好的理解】
57:05 小端序和大端序
1:01:19 数据表示的例子
1:08:38 字符串部分「很简单地略过」
1:09:58 整数问题的小测验



## 关于数字的运算

**加法运算：溢出时直接截断溢出的位数**

无符号数
$$
s=UAdd_w(u,v)=u+v\ mod\ 2^w ,w是数字的位宽
$$
有符号数

- 存在补码溢出的问题（截断超出的位数的基础上，符号位的数字直接影响了正负）

**乘法运算

![image-20201024181209362](/img/cloudNetworkingClass/2020-10-24-CSAPP%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E8%8A%82/image-20201024181209362.png)

乘以2^k这类特定的数

- u << k 即 $u*2^k$
-  对有符号数和无符号数同 生效
- 编译器会自动判定，用移位替代乘法

除以以2^k这类特定的数 

- u >>k 即$u/(2^k)$取整
-  对有符号数和无符号数同时生效
- 除法的开销依然很大，编译器会做一些相关的操作来优化

一些取负值的方法

- $x \rightarrow -x$ 按位取反+1

![image-20201024182809377](/img/cloudNetworkingClass/2020-10-24-CSAPP%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E8%8A%82/image-20201024182809377.png)

一个关于位计算的例子

![image-20201024183753880](/img/cloudNetworkingClass/2020-10-24-CSAPP%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E8%8A%82/image-20201024183753880.png)

这种循环会在i发生溢出后停止（有点反直觉）

-----

## 数字在内存，指针，字符串的表示

![image-20201024221235220](/img/cloudNetworkingClass/2020-10-24-CSAPP%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E8%8A%82/image-20201024221235220.png)

通常用地址来查询数据（64位操作系统意味着可以管理$2^{64}$个地址)

- 可以假设内存一个非常的大的数组（实际上不是，但是可以这样子理解）
- 跨域通过地址来访问对应元素的位置（指针所指向的变量存储的位置）

备注：系统提供一个私有的地址空间给每一个程序

- 假设某一个程序被清理了，则会回收相应的空间
- 因此，程序可以访问自己的数据，而被你访问其他应用的

### Machine Word(字长)

- 内存中指针表示的范围，或者能寻址到的最大的数据块是多少【模糊的定义，因为实际上64位机器的int的字长也是4bytes】

  （但是64位机器特点是，指针的长度也为64bit，而32位机的指针为32bit）

- 例如32位（4 bytes）作为字长的，内存的限制在4GB（$2^{32}$byte)；而64位机器则支持到最高18PB的数据（虽然实际上使用到了47位级128TB（$2^{47}$byte）为止）;

- 机器支持不同的数据类型（64位兼容32位），编译器也同样支持编译得到不同寻址大小的程序

![image-20201024224447017](/img/cloudNetworkingClass/2020-10-24-CSAPP%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E8%8A%82/image-20201024224447017.png)

不同的字长机器的单个数据块大小不同，为了提高效率，编译器会尽可能去对齐

### 字节顺序

大端字节（big endian）：Internet，Sun

- 数据包中的byte通常是从高位到低位的顺序来记录数据（比如说16的端口号，就是高位在前低位在后），在直接读取数据包的时候会发现；

- 数据包发送到网内时采用的是小端字节序

小端字节（Little endian）：X86，Arm over Android, IOS, and windows

- 数据块中内容的byte从低位在前高位在后来记录数据；**（包括符号位）**

![image-20201024225440177](/img/cloudNetworkingClass/2020-10-24-CSAPP%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E8%8A%82/image-20201024225440177.png)

 

![image-20201024230330784](/img/cloudNetworkingClass/2020-10-24-CSAPP%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E8%8A%82/image-20201024230330784.png)



一个打印地址内容的程序

```c
typedef unsigned char *pointer;
void show_bytes(pointer start, size_t len){
    size_t i;
    for(i=0;i<len;i++){
        printf("%p\t0x%.2x\n",start+i,start[i]);//分别打印地址和内容；%p表示指针地址，%x表示16进制输出内容，i为偏移量，最单位为byte
    }
    printf("\n")
}
```

![image-20201024230832150](/img/cloudNetworkingClass/2020-10-24-CSAPP%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E8%8A%82/image-20201024230832150.png)

备注：

字符串（string）的排序都是按字节的顺序进行，以"0x00"作为结束符 【ASCII码】

一些神秘例题，见课本