---
layout:     post
title:      【课堂笔记】CSAPP Lecture 4 Floating
subtitle:   basic
date:       2020-11-2
author:     haoran
header-img: img/cover/snapshot.png
catalog: true
tags: 

    - CSAPP
    - encoding

typora-root-url: ..
---



## Lecture 4 浮点数 

## 观看记录

2:44 二进制分数的表示，浮点数“浮点”的来源
08:07 IEEE floating point
08:25 浮点数的表示
10:56 规格化的值
20:20 解释exp阶码部分，这个地方其实解释有误；其实展示的是阶码整体的范围，包括非规格化时；
23:53 非规格化的值
26:14 特殊值
28:29 浮点数编码的可视化

29:49 浮点数编码的简单例子
39:56 浮点数编码的属性

41:34 浮点数运算的基本思想(运算后舍入)
44:25 舍入的方法
51:33 二进制的舍入
54:56 浮点数的乘法
56:30 浮点数的加法
56:54 浮点数加法和乘法的数学性质
62:59 C中的浮点数
67:20 浮点数的练习题



# 浮点数

浮点数的表示
$$
\sum^i_{k=-j}b_k\cdot 2^k
$$


![image-20201102211311427](/img/cloudNetworkingClass/2020-10-25-CSAPP%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E8%8A%82/image-20201102211311427.png)

## 浮点数的编码标准

$$
(-1)^s\cdot M\cdot2^E
$$

- s是符号位
- E表示指数编码（阶码）
- M表示数值范围（1，2）也可以理解为1.M

![image-20201102212034364](/img/cloudNetworkingClass/2020-10-25-CSAPP%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E8%8A%82/image-20201102212034364.png)

## 表示方法


| 规格化的   | s    | 不全为1或0 | 1101 1011 0110 1000 0000 000 |
| ---------- | ---- | ---------- | ---------------------------- |
|            | s    | Exp        | frac                         |
| 非规格化的 | s    | 全为0      | 1101 1011 0110 1000 0000 000 |
| 无穷大的   | s    | 全为1      | 全为0                        |
| NaN        | s    | 全为1      | 不全为0                      |

### 规格化的值  Normalized values

- E = Exp - bias （阶码）
  - Exp: 无符号数的exp域
  - $Bais = 2^{k-1}-1$，where k is number of exponent bits
    - 单精度浮点数范围8bit： 127（Exp：0....254, E:-126...127) ，$E=指数位数+2^7-1$
    - 双精度浮点16bit：1023（Exp：1....2046, E:-1022...1023)，$E=指数位数+2^{16}-1$

- Significand coded（尾数） with implied leading 1：M = 1.xxx...x (这个1不纳入编码范围，即认为是自带的)

  - xxx.x: bits of frac field
  - Minimum when frac = 000...0 (M=1,0)
  - Maximum when frac=111...1(M=2.0-$\epsilon$)
  - Get extra leading bit for "free"
#### 例子（规格化的）
- Value float F = 15213.0
  - $15213_{10}=1110\ 1101\ 1011\ 01_{2}$

    ​              $=1.110\ 1101\ 1101\ 01_{2}\cdot2^{13}$
  
- Significand  尾数
   - $M = 1.110\ 1101\ 1011\ 01_2$ 尾数 
   - $frac = 1101\ 1011\ 0110\ 1000\ 0000\ 000$ 共23位（frac的位数，省略掉M中的1，然后补齐23位）
   
- Exponent 阶码
      E = 13
      Bias = 127 = $2^7-1$
      Exp = E+Bias = 140 = 1000 1100(2)
  
- Result 

  | s    | Exp       | frac                         |
  | ---- | --------- | ---------------------------- |
  | 0    | 1000 1100 | 1101 1011 0110 1000 0000 000 |
  

32bit 浮点数：
1. Exp的编码取值范围[1,254] 对应二进制数 0000 0001 和 1111 1110
2. E的取值范围[-126,128]，E = Exp -  bias  这里bias的取值为127

### 情况2 非规格化的值 exp = 000...0

原因：采用规格化的没法表示0，因为始终有一个M的前置值

此时的阶码 E = 1-bias （bias此时根据float和double选择127或者1023）
1. 用于表示数字0包括+0和-0
2. 用于表示接近0的数字0. exp = 0000.00, frac ≠ 0；

### 情况3 ： 非规格化的值 exp = 111....111 全为1 的情况

- Case ： exp = 111...1 , frac = 000...0
  - 表示无穷大
  - overflow
  - 同时存在+∞和－∞，例如1/-0.0 = -∞
- Case ： exp = 111...1 , frac ≠ 000...0
  - 不是一个数 NaN
  - e.g sqrt(-1), ∞+∞

![image-20201103172810632](/img/cloudNetworkingClass/2020-10-25-CSAPP%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E8%8A%82/image-20201103172810632.png)



  

#### 例子

8bit的浮点数，其中1位符号位四位阶码（exp）此时$bais=2^3-1=7$，三位尾数（significand）

| s符号位 | exp阶码 | frac尾数 | E指数  | 实际值value                                         |
| ------- | ------- | -------- | ------ | --------------------------------------------------- |
| 0       | 0000    | 000      | 1-7=-6 | 0                                                   |
| 0       | 0000    | 001      | -6     | $2^{-3}\cdot2^{-6}=2^{-9}=1/512$                    |
| 0       | 0000    | 111      | -6     | $(2^{-1}+2^{-2}+2^{-3})\cdot2^{-6}=7/512$           |
| 0       | 0001    | 000      | 1-7=-6 | $(1)\cdot2^{-6}=1/64=8/512$  (注意，这里平滑过渡了) |
| 0       | 0101    | 101      | 5-7=-2 | $(1+2^{-1}+2^{-3})\cdot2^{-2}=13/32$                |
| 0       | 0101    | 110      | -2     | $(1+2^{-1}+2^{-2})\cdot2^{-2}=14/32$                |
| 0       | 0110    | 110      | 6-7=-1 | $(1+2^{-1}+2^{-2}) \cdot 2^{-1}= 14/16$             |
| 0       | 0110    | 111      | -1     | $(1+2^{-1}+2^{-2}+2^{-3}) \cdot 2^{-1}= 15/16$      |
| 0       | 1110    | 110      | 7      | $(1+2^{-1}+2^{-2}) \cdot 2^{7}= 224$                |
| 0       | 1110    | 111      | 7      | $(1+2^{-1}+2^{-2}+2^{-3}) \cdot 2^{7}= 240$         |
| 0       | 1111    | 000      | NaN    | INF                                                 |
|         |         |          |        |                                                     |



- 越靠近0的地方划分的粒度越细致，编码的长度越长，同样精度也会越高

- 0 0000 111到0 0001 000可以平滑过渡
- 可以进行对其进行大小比较
- 相同exp上的数字的间隔相同

![image-20201103210057578](/img/cloudNetworkingClass/2020-10-25-CSAPP%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E8%8A%82/image-20201103210057578.png)

 

## 浮点数的操作

- X+fY = Round(X+Y)
- X*fY = Round(X*Y)



## 舍入（rounding）操作

![image-20201103222337270](/img/cloudNetworkingClass/2020-10-25-CSAPP%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E8%8A%82/image-20201103222337270.png)

IEEE采用了偶数舍入的方式（nearest even），即当超出精度范围的数

- 大于最小精度的一半时向上舍入；
- 小于时向下舍入；
- 等于时向偶数舍入；



## 二进制数的舍入操作（偶数舍入法）

- 二进制代码
  - “even” 当尾数的最后一位为0
  - “Half way”  when bits to right of rounding position = 100..(2)

- 实例

  - 估计1/4bit的值

    | Value  | Binary       | Rounded  | Action    | Rounded Value |
    | ------ | ------------ | -------- | --------- | ------------- |
    | 2 2/32 | 10.00 011(2) | 10.00(2) | <1/2-down | 2             |
    | 2 3/16 | 10.00 110(2) | 10.01(2) | >1/2-up   | 2 1/4         |
    | 2 7/8  | 10.11 100(2) | 11.00(2) | 1/2-up    | 3             |
    | 2 5/8  | 10.10 100(2) | 10.10(2) | 1/2-down  | 2 1/2         |
    |        |              |          |           |               |

## 乘法

- $(-1)^{s1}M1\cdot2^{E1}\cdot(-1)^{s1}M2\cdot2^{E2}$
- Exact Result:$(-1)^sM2^E$
  - Sign s :    s1 xor s2
  - Significant M: $M1\cdot M2$ 
  - Exponent E: E1+E2

- 备注
  - 如果M>=2，需要对M进行移位并增大E
  - 如果E超出范围，则溢出了计算值
  - Round M to fit frac precision
- 实现
  - 符号位是两个符号的异或值

## 加法

![image-20201104174201817](/img/cloudNetworkingClass/2020-10-25-CSAPP%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E8%8A%82/image-20201104174201817.png)

对齐后做加法，并调整为设计的规则。

备注：

- 加法的这种规则，可能使得浮点数的运算不满足结合律

   e.g. (3.14+1e10)-1e10 = 0; 3.14+(1e10-1e10)=3.14

- 浮点数的乘法也可能不满足结合率



## Floating Point in C

- 格式转换

  double/float -> int

  - 去掉小数部分
  - float可以直接转
  - NaN 或者 overflow 转为Tmin

  int -> double

  - 精确转换

  int -> float

  - 取近似（int的有效位有32位但是float只有23位）





